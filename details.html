<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Detail View</title>

  <!-- External libraries -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdbe-molstar@3.2.0/build/pdbe-molstar-plugin.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pdbe-molstar@3.2.0/build/pdbe-molstar-light.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
  <script src="https://string-db.org/javascript/combined_embedded_network_v2.0.4.js"></script>
  <script src="https://unpkg.com/cytoscape@3.32.0/dist/cytoscape.min.js"></script>

  <style>
    body {
      font-family: Helvetica, sans-serif;
      width: 90%;
      margin: auto;
    }
    .small-text {
      font-size: 14px;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      /*justify-content: space-between;*/
      justify-content: center;
      gap: 66px;
    }
    .container-small {
      display: flex;
      flex-wrap: wrap;
      /*justify-content: space-between;*/
      gap: 6px;
    }

    .column {
      flex: 1;
      min-width: 0px;
    }

    .small-column {
      flex: 5;
      min-width: 0; /* helps with resizing */
    }

    .large-column {
      flex: 8;
      min-width: 0;
    }

    #PDBeviewer{
      width: 656px;
      height: 400px;
      position: relative;
      overflow: hidden;
    }
    #stringEmbedded {
      width: 400px;
      height: 50px;
      position: relative;
      overflow: hidden;
    }
    #stringAppContainer {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    #network-container {
      /* Size + spacing */
      width: 656px;
      height: 300px;
      margin-bottom: 1rem;

      /* Visuals */
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      background: #fafafa;

      /* let it shrink on narrow screens */
      min-width: 250px;
      overflow: hidden;
    }
    #PAEcontainer, #profileA, #profileB {
        width: 387.096775px;             /* Set width */
        height: 300px;            /* Set height */
        border: 1px solid #ccc;   /* Add a light border */
        justify-content: center;  /* Center the figure horizontally */
        align-items: center;      /* Center the figure vertically */
    }
    #paefig {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain; /* Maintain aspect ratio */
        /*
        */
    }
    /* buttons */
    .center-button {
        display: flex;
        justify-content: center;
        padding:0px;
        margin-top: 10px;
    }

    .button-small {
        width: 80px;
        padding: 6px;
        text-align: left;
        margin: 5px 5px;
    }
    .button-medium {
        width: 280px;
        padding: 5px;
        text-align: left;
        margin: 1px 1px;
    }
    .button-large {
        width: 392px;
        padding: 1px;
        text-align: left;
        margin: 5px 5px;
    }
    .back-button {
        display: inline-block;
        margin-bottom: 5px;
        padding: 5px 5px;
        font-size: 16px;
        color: #fff;
        background-color: #007bff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-decoration: none;
    }
    .back-button:hover {
        background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h2>Details for ID: <span id="entry-id"></span></h2>
  <h3>Protein Details</h3>
  <p>Protein A: <span id="proteinA"></span>, <span id="geneA"></span>, <span id="annotationA"></span></p>
  <p>Protein B: <span id="proteinB"></span>, <span id="geneB"></span>, <span id="annotationB"></span></p>
  <h3>Prediction Detail</h3>
  <p>iptm: <span id="iptm"></span>, PAE: <span id="pae"></span>, pDockQ: <span id="pdockq"></span>, confidence of interaction: <span id="ppi"></span></p>
  <br>
  <div class="container">

    <!--Structure Column-->
    <div class="large-column">
      <h3>AF2 Model</h3>
      <div id="PDBeviewer"></div>
      <h3> Click below to show Interface </h3>
      <div class="container-small">
        <!--<div class="column">-->
          <button class="button-medium" id="selectChainA">
            Interface in Protein A (<span id="geneAbutton"></span>): <br><span id="interfaceA"></span>
          </button>
        <!--</div>-->
        <!--
        <div class="column">
        -->
          <button class="button-medium" id="selectChainB">
            Interface in Protein B (<span id="geneBbutton"></span>): <br><span id="interfaceB"></span>
          </button>
        <!--
        </div>
        -->
        <!--
      </div>
      <div class="center-button">
        -->
        <button class="button-small" id="clearselection">Clear Selection</button>
        <!--
      </div>
        -->
      </div>
      <!-- Interaction network (A—B + highconf partners) -->
      <br>
      <h3>Position in predicted high confidence PPI Network</h3>
      <p>Note it is <span id="ppiNet"></span></p>
      <div id="network-container"></div>
      <br>
      <h3>STRING Network</h3>
      <p>click the logo to check details in the version 11.5 STRING database</p>
      <div id="stringEmbedded"> <div id="stringAppContainer"></div> </div>
      <br><a id="modelpath" href="#" download>Download the model</a>
      <br><br>
    </div>
    <!--End of Structure Column-->

    <!--PAE session-->
    <div class="small-column">
      <h3>Predicted Aligned Error</h3>
      <div id="PAEcontainer"><img id="paefig" style="width: 100%; height: 100%; object-fit: contain;"></div>
      <h3>Protein A (<span id="geneA_IF"></span>) interface binding mode(s)</h3>
      <div id="profileA"></div>
      <h3>Protein B (<span id="geneB_IF"></span>) interface binding mode(s)</h3>
      <div id="profileB"></div>
      <p>IF(IDR): disordered binding<br>IF(CF): conditionally folded binding<br>IF(coil2order): coil-to-order binding<br>IF(order): ordered interface</p>
      <p id="profileNote" class="muted" style="display:none;"></p>
    </div>
    <!--End of PAE session-->

  </div>

  <a href="index.html" class="back-button">Back to List</a>

  <script>
    const id = new URLSearchParams(window.location.search).get("id");
    document.getElementById("entry-id").textContent = id;
    //document.getElementById("modelpath").href = `./data/pdb/${id}.pdb`;
    document.getElementById('modelpath').href = `https://storage.googleapis.com/dmelppi_web/mpdb/${id}.pdb.gz`;
    //document.getElementById("paefig").src = `./data/PAE/${id}_pae.png`;
    document.getElementById("paefig").src = `https://storage.googleapis.com/dmelppi_web/mPAE/${id}_pae.jpg`;

    //const viewerInstance = new PDBeMolstarPlugin();
    //const viewerContainer = document.getElementById("PDBeviewer");

        // read gzip txt
        async function fetchGzAsText(url) {
      const resp = await fetch(url);
      const buf  = await resp.arrayBuffer();        // raw gzip bytes
      const uint = new Uint8Array(buf);
      return new TextDecoder().decode(pako.inflate(uint));
    }

    // load partners, if file not exist, return empty partners
    async function loadPartnerList(proteinId, basePath = './data/networks/') {
        const url = `${basePath}${proteinId}.txt.gz`;

        try {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const buf  = await resp.arrayBuffer();
            const uint = new Uint8Array(buf);
            const text = new TextDecoder().decode(pako.inflate(uint));
            return text.split(/\s+/).filter(Boolean); // return partner IDs
        } catch (err) {
            return [];   // return empty partners 
        }
    }

        /* ---------- main renderer --------------------------------------------- */
        async function renderPartnerNetwork({
        proteinAId,             // use Gene symbols here
        proteinBId,             // 
        geneAId,
        geneBId,
        ppi,
        basePath = './data/networks/'  // folder containing *.txt.gz
    } = {}) {

        /* 1 ─ fetch partner lists */
      const [partnersA, partnersB] = await Promise.all([
        loadPartnerList(proteinAId, basePath),
        loadPartnerList(proteinBId, basePath)
      ]);
  
      /* 2 Build Cytoscape elements */
      proteinAId = geneAId;
      proteinBId = geneBId;
      const unique = new Set([proteinAId, proteinBId]);
      const nodes  = [
        { data: { id: proteinAId, label: proteinAId, type: 'anchor' } },
        { data: { id: proteinBId, label: proteinBId, type: 'anchor' } }
      ];

      function pushPartner(id) {
        if (!unique.has(id)) {
          unique.add(id);
          nodes.push({ data: { id, label: id, type: 'partner' } });
        }
      }
      partnersA.forEach(pushPartner);
      partnersB.forEach(pushPartner);

            // add edges 
            const edges   = [];
      const edgeKey = new Set();

      function addEdge(a, b, ppiTag = 'partner') {     // default = partner
        const key = a < b ? `${a}|${b}` : `${b}|${a}`; // canonical order
        if (edgeKey.has(key)) return;
        edgeKey.add(key);
        edges.push({ data: { id: key, source: a, target: b, ppi: ppiTag } });
      }

      ///* A—B edge only if partner files exist AND ppi ≠ "no" */
      ///*const showAB = (partnersA.length || partnersB.length) && (ppi !== 'no');*/
      const showAB = (ppi !== 'no or low confidence interactions');
      if (showAB) {
        //console.log(`adding A–B edge with ppi = ${ppi}`);
        addEdge(proteinAId, proteinBId, ppi);
      }

      /* A ↔ partnersA  (tagged as "partner") */
      partnersA
        .filter(p => p !== proteinBId)                   // avoid duplicate A-B
        .forEach(p => addEdge(proteinAId, p));

      /* B ↔ partnersB  (tagged as "partner") */
      partnersB
        .filter(p => p !== proteinAId)                   // avoid duplicate B-A
        .forEach(p => addEdge(proteinBId, p));

            /* 3 Initialise (or re-initialise) Cytoscape */
            const container = document.getElementById('network-container');
      container.innerHTML = '';          // clear previous graph if any
     
      cytoscape({
        container,
        elements: { nodes, edges },
        layout:   { name: 'cose', fit: true, padding: 40 },
     
        style: [
          /* anchors: A & B */
          {
            selector: 'node[type = "anchor"]',
            style: {
              'background-color': '#dc9f70',
              'width': 55, 'height': 55,
              'label': 'data(label)',
              //'font-weight': 'bold',
              'font-size': 18,
              'color': '#303030',
              'text-valign': 'center',
            }
          },
          /* partners */
          {
            selector: 'node[type = "partner"]',
            style: {
              'background-color': '#96c8fa',
              'width': 33, 'height': 33,
              'label': 'data(label)',
              'font-size': 16,
              'color': '#303030',
              'text-valign': 'center'
            }
          },
          /* edges */
          {
            selector: 'edge[ppi = "high confidence interactions"]',
            style: {'line-color':'#0000FF','width':4,'line-style':'solid' }
          },
          {
            selector: 'edge[ppi = "acceptable interactions"]',
            style: {'line-color':'#00bcd4','width':3,'line-style':'solid','opacity':0.9 }
          },
          {
            selector: 'edge[ppi = "possible interactions"]',
            style: {'line-color':'#808080','width':3,'line-style':'dashed','opacity':0.7}
          },
          {
            selector: 'edge[ppi = "partner"]',
            style: {'line-color':'#808080','width':3,'line-style':'solid' }
          },
        ]
      });
    }

    function ss_to_rgb_array(ss) {
      return ss.map(code => {
        if (code === 1) return 0.5; // helix
        if (code === 2) return 1.0; // strand
        return 0.0; // coil
      });
    }

    // interface to array
    function rangesToBinaryTrack(rangesStr, length) {
      const binaryTrack = new Array(length).fill(0);
      if (!rangesStr || typeof rangesStr !== "string" || rangesStr.trim() === "") return binaryTrack;

      const ranges = rangesStr.split(";");

      for (const range of ranges) {
        const [start, end] = range.split("-").map(Number);
        for (let i = start - 1; i < end; i++) {
          if (i >= 0 && i < length) binaryTrack[i] = 1;
        }
      }
      return binaryTrack;
    }

    function renderProfile(containerId, info, key) {
      const x = Array.from({ length: info.monomer_plddt[key].length }, (_, i) => i);
      const plddt = info.monomer_plddt[key].map(v => v / 100);
      const isd = info.monomer_isd[key].map(v => v / 100);
      const ss_mono = ss_to_rgb_array(info.monomer_ss[key]);
      const ss_complex = ss_to_rgb_array(info.complex_ss[key]);
      const idr = rangesToBinaryTrack(info.idr_if?.[key] ?? "", x.length);
      const cf = rangesToBinaryTrack(info.CF_if?.[key] ?? "", x.length);
      const c2o = rangesToBinaryTrack(info.coil2order_if?.[key] ?? "", x.length);
      const ord = rangesToBinaryTrack(info.order_if?.[key] ?? "", x.length);

      const data = [
        { x, y: plddt, type: 'scatter', name: 'PLDDT', line: { color: 'blue' }, yaxis: 'y1' },
        { x, y: isd, type: 'scatter', name: 'ISD', line: { color: 'black' }, yaxis: 'y1' },
        { z: [ss_mono], type: 'heatmap', name: 'SS (monomer)', showscale: false, yaxis: 'y2', xaxis: 'x', coloraxis: "coloraxis",zmin:0,zmax:1},
        { z: [ss_complex], type: 'heatmap', name: 'SS (complex)', showscale: false, yaxis: 'y3', xaxis: 'x', colorscale: [[0, '#ADD8E6'], [0.5, '#8000D7'], [1.0, '#FF8C00']],zmin:0,zmax:1},
        { z: [idr], type: 'heatmap', name: 'IF(IDR)', showscale: false, yaxis: 'y4', xaxis: 'x', colorscale: [[0, 'lightgray'], [1, '#8B0000']],zmin: 0,zmax: 1, },
        { z: [cf], type: 'heatmap', name: 'IF(CF)', showscale: false, yaxis: 'y5', xaxis: 'x', colorscale: [[0, 'lightgray'], [1, '#8B0000']],zmin: 0,zmax: 1, },
        { z: [c2o], type: 'heatmap', name: 'IF(coil2order)', showscale: false, yaxis: 'y6', xaxis: 'x', colorscale: [[0, 'lightgray'], [1, '#8B0000']],zmin: 0,zmax: 1,  },
        { z: [ord], type: 'heatmap', name: 'IF(order)', showscale: false, yaxis: 'y7', xaxis: 'x', colorscale: [[0, 'lightgray'], [1, '#8B0000']],zmin: 0,zmax: 1,  }
      ];

      const yLabels = [
        ['PLDDT/ISD', -0.3,0.96],
        ['SS (monomer)',-0.35,0.54],
        ['SS (complex)',-0.32,0.45],
        ['IF(IDR)',-0.18,0.35],
        ['IF(CF)',-0.16,0.22],
        ['IF(coil2order)',-0.33,0.12],
        ['IF(Ordered)',-0.29,0.02]
      ];

      const annotations = yLabels.map(([text, x,y]) => ({
        text,
        xref: 'paper',
        yref: 'paper',
        x,
        y,
        showarrow: false,
        textangle: 0,
        font: { size: 10 },
        align: 'center'
      }));

      const layout = {
        height: 300,  
        margin: {t: 1, b: 1 },
        xaxis:  {domain: [0, 1],showticklabels:true,side:'top',tickfont:{size:10},showline: true},
        yaxis:  {domain: [0.62, 0.92],title:'', range: [0, 1], tickvals: [0.5, 0.7], ticktext: ['0.5','0.7'],tickfont:{size:10}},
        yaxis2: {domain: [0.52, 0.57],title:'', showticklabels:false, ticks:''},
        yaxis3: {domain: [0.42, 0.47],title:'', showticklabels:false, ticks:''},
        yaxis4: {domain: [0.32, 0.37],title:'', showticklabels:false, ticks:''},
        yaxis5: {domain: [0.22, 0.27],title:'', showticklabels:false, ticks:''},
        yaxis6: {domain: [0.12, 0.17],title:'', showticklabels:false, ticks:''},
        yaxis7: {domain: [0.02, 0.07],title:'', showticklabels:false, ticks:''},
        legend: {
          x: 0.99,
          y: 0.90,
          bgcolor: 'rgba(255,255,255,0.9)',
          bordercolor: 'white',
          borderwidth: 0,
          font: {size: 10},
          itemwidth: 15
        },
        shapes: [
          { type: 'line', xref: 'paper', x0: 0, x1: 1, yref: 'y1', y0: 0.5, y1: 0.5, line: { color: 'black', width: 1, dash: 'dot' } },
          { type: 'line', xref: 'paper', x0: 0, x1: 1, yref: 'y1', y0: 0.7, y1: 0.7, line: { color: 'blue', width: 1, dash: 'dot' } }
        ],
        coloraxis: {
            // repeat each colour at its start & end value → sharp steps
            colorscale: [
                [0.00, '#ADD8E6'],   // coil  (light-blue)  0.00‒0.333
                [0.33, '#ADD8E6'],

                [0.33, '#8000D7'],   // helix (purple)      0.333‒0.666
                [0.66, '#8000D7'],

                [0.66, '#FF8C00'],   // strand (orange)     0.666‒1.00
                [1.00, '#FF8C00']
            ],
            cmin: 0,
            cmax: 1,

            colorbar: {
                //title: { text: 'Secondary&nbsp;structure', side: 'right' },
                x: 1.020,
                y: 0.5,
                len: 0.18,          // 20 % of plot height
                thickness: 6,

                tickmode: 'array',
                tickvals: [0.165, 0.495, 0.83],   // mid-point of each block
                ticktext: ['Coil', 'Helix', 'Strand'],

                ticklen: 0,        // hide little tick marks
                tickfont: { size: 10 }
            }
        },
        annotations
      };

      Plotly.newPlot(containerId, data, layout);
    }

    function ViewStructure(id) {
      fetch(`./data/json_meta/${id}.meta.json.gz`)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.arrayBuffer(); // Gzipped binary
        })

        .then(buffer => {
          const decompressed = pako.inflate(new Uint8Array(buffer), { to: 'string' }); // Decompress the data
          const info = JSON.parse(decompressed); // Parse the decompressed JSON

          // Show prediction detail
          document.getElementById('iptm').textContent = info.iptm;
          document.getElementById('pae').textContent = info.pae + ' Å';
          document.getElementById('pdockq').textContent = info.pdockq;
          document.getElementById('ppi').textContent = info.ppi;
          document.getElementById('ppiNet').textContent = info.ppi;
    
          // Show Annotation
          document.getElementById('proteinA').textContent = info.proA;
          document.getElementById('proteinB').textContent = info.proB;
          document.getElementById('geneA').textContent = info.geneA;
          document.getElementById('geneB').textContent = info.geneB;
          document.getElementById('geneAbutton').textContent = info.geneA;
          document.getElementById('geneBbutton').textContent = info.geneB;
          document.getElementById('geneA_IF').textContent = info.geneA;
          document.getElementById('geneB_IF').textContent = info.geneB;
          document.getElementById('annotationA').textContent = info.annotationA;
          document.getElementById('annotationB').textContent = info.annotationB;

          const url = (info && info.ppi === 'high confidence interactions')
            ? `./data/highconfPDB/${id}.pdb.gz`
            : `https://storage.googleapis.com/dmelppi_web/mpdb/${id}.pdb.gz`;
          const viewerInstance = new PDBeMolstarPlugin();
          const viewerContainer = document.getElementById("PDBeviewer");
          viewerInstance.render(viewerContainer, {
            moleculeId: id,
            customData: {
              //url: `./data/pdb/${id}.pdb`,
              //url: `https://storage.googleapis.com/dmelppi_web/mpdb/${id}.pdb.gz`,
              url,
              format: 'pdb',
              binary: url.endsWith('.gz'),
            },
            bgColor: { r: 255, g: 255, b: 255 },
            hideControls: true,
            pdbeLink: false,
            visual: {
              colorTheme: {
                name: "chain-id",
                params: {
                  chainIdColorMap: {
                    A: { r: 0, g: 255, b: 255 },
                    B: { r: 255, g: 0, b: 0 }
                  }
                }
              }
            }
          });


          document.getElementById("interfaceA").textContent = info.interfaceA;
          document.getElementById("interfaceB").textContent = info.interfaceB;

          document.getElementById("selectChainA").onclick = () => {
            viewerInstance.visual.select({ data: info.interfaceA_sel });
          };
          document.getElementById("selectChainB").onclick = () => {
            viewerInstance.visual.select({ data: info.interfaceB_sel });
          };
          document.getElementById("clearselection").onclick = () => {
            viewerInstance.visual.clearSelection();
          };

          // STRING network using version 11.5
          document.getElementById("stringAppContainer").id = "stringEmbedded";
          //getSTRING("https://string-db.org", {
          getSTRING("https://version-11-5.string-db.org", {
            species: 7227,
            network_flavor: "evidence",          // or "confidence"
            identifiers: [info.proA, info.proB],
            caller_identity: "DmelPPI_web"
          });

          // Interface plot
          //const pdockq = Number(info.pdockq);
          const ppiStatus = (info.ppi || '').trim().toLowerCase();
          const note   = document.getElementById('profileNote');
          //if (pdockq >= 0.23) {
          if (ppiStatus !== 'no or low confidence interactions') {
            // Line + track plot for each protein
            renderProfile("profileA", info, info.proA);
             renderProfile("profileB", info, info.proB);
          } else {
            document.getElementById("profileA").style.display = "none";
            document.getElementById("profileB").style.display = "none";
            note.textContent =
              `Interface detail not shown because it's of low confidence`;
            note.style.display = 'block';
          }

          // show the network
          const proteinAId = info.proA;   // from JSON or URL
          const proteinBId = info.proB;
          const geneAId = info.geneA;   // from JSON or URL
          const geneBId = info.geneB;
          const ppi = info.ppi;
          renderPartnerNetwork({ proteinAId,proteinBId,geneAId,geneBId,ppi});
        });
    }

    ViewStructure(id);
  </script>
</body>
</html>

